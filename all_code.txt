===== File: ./tests/test_error_handling.c =====



===== File: ./tests/test_stack_init.c =====



===== File: ./tests/test_sorting.c =====



===== File: ./tests/test_helpers.c =====



===== File: ./src/main_radix.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main_radix.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/29 21:30:04 by procha-r          #+#    #+#             */
/*   Updated: 2025/05/01 19:12:40 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"
#include <stdio.h>
#include <unistd.h>

static void	sort_stack(t_stack *a, t_stack *b)
{
	if (a->size == 2)
	{
		if (a->top->value > a->top->next->value)
			sa(a);
	}
	else if (a->size == 3)
		sort_three(a);
	else if (a->size > 3 && a->size <= 5)
		sort_five(a, b);
	else
		sort_big(a, b);
}

int	main(int argc, char **argv)
{
	t_stack	a;
	t_stack	b;
	int		parse_result;

	if (argc == 1)
		return (0);
	init_stack(&a);
	init_stack(&b);
	parse_result = parse_input(argc, argv, &a);
	if (parse_result == -1)
	{
		print_error();
		handle_exit(&a, &b);
	}
	if (is_sorted(&a))
	{
		free_stack(&a);
		free_stack(&b);
		return (0);
	}
	assign_index(&a);
	sort_stack(&a, &b);
	free_stack(&a);
	free_stack(&b);
	return (0);
}



===== File: ./src/parse/parse_input.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_input.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pedroribeiro <pedroribeiro@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/29 22:25:56 by procha-r          #+#    #+#             */
/*   Updated: 2025/05/02 17:34:35 by pedroribeir      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	is_valid_int(const char *arg)
{
	int	i;

	i = 0;
	if (!arg || arg[0] == '\0')
		return (0);
	if (arg[i] == '-' || arg[i] == '+')
		i++;
	if (arg[i] == '\0')
		return (0);
	while (arg[i])
	{
		if (arg[i] < '0' || arg[i] > '9')
			return (0);
		i++;
	}
	return (1);
}

int	check_duplicates(t_stack *a)
{
	t_node	*current;
	t_node	*runner;

	if (!a || !a->top)
		return (0);
	current = a->top;
	while (current)
	{
		runner = current->next;
		while (runner)
		{
			if (runner->value == current->value)
				return (1);
			runner = runner->next;
		}
		current = current->next;
	}
	return (0);
}

int	parse_input(char **args, t_stack *a, int count)
{
	int	i;
	int	num;

	if (!args || count < 1)
		return (-1);
	i = count - 1;
	while (i >= 0)
	{
		if (!is_valid_int(args[i]) || !safe_atoi(args[i], &num))
			return (-1);
		push_stack(a, num, -1);
		i--;
	}
	return (0);
}



===== File: ./src/parse/normalize_argv.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   normalize_argv.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pedroribeiro <pedroribeiro@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 16:58:43 by pedroribeir       #+#    #+#             */
/*   Updated: 2025/05/02 17:17:53 by pedroribeir      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

t_input	normalize_argv(int argc, char **argv)
{
	t_input	in;

	in.args = NULL;
	in.count = 0;
	in.is_split = 0;
	if (argc == 2)
	{
		in.is_split = 1;
		in.args = ft_split(argv[1], ' ');
		in.count = ft_count_split(in.args);
	}
	else
	{
		in.is_split = 0;
		in.args = &argv[1];
		in.count = argc - 1;
	}
	return (in);
}



===== File: ./src/algo/sort_large.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sort_large.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/28 10:58:42 by pedroribeir       #+#    #+#             */
/*   Updated: 2025/04/28 17:14:48 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "sorting.h"
#include "operations.h"

static int	calculate_chunk_size(int total)
{
	int	k;

	k = 11;
	if (total % k == 0)
		return (total / k);
	return (total / k + 1);
}

static void	get_chunk_bounds(int chunk, int chunk_size, int *lo, int *hi)
{
	*lo = chunk * chunk_size;
	*hi = *lo + chunk_size - 1;
}

void	sort_large(t_stack *a, t_stack *b)
{
	int	total;
	int	chunk_size;
	int	chunk;
	int	lo;
	int	hi;

	if (!a || !b || a->size <= 5)
		return ;
	total = a->size;
	chunk_size = calculate_chunk_size(total);
	chunk = 0;
	while (chunk < (total / chunk_size + (total % chunk_size != 0)))
	{
		get_chunk_bounds(chunk, chunk_size, &lo, &hi);
		push_chunk_to_b_big(a, b, lo, hi);
		chunk++;
	}
	pull_b_to_a(a, b);
}



===== File: ./src/algo/big_sorts.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   big_sorts.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/23 12:56:46 by procha-r          #+#    #+#             */
/*   Updated: 2025/05/01 21:17:23 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	radix_sort(t_stack *a, t_stack *b)
{
	int	i;
	int	j;
	int	size;
	int	max_bits;

	i = 0;
	size = stack_size(a);
	max_bits = 0;
	while ((size - 1) >> max_bits)
		max_bits++;

	while (i < max_bits)
	{
		j = 0;
		while (j++ < size)
		{
			if (((a->top->index >> i) & 1) == 1)
				ra(a);
			else
				pb(a, b);
		}
		while (!is_empty(b))
			pa(a, b);
		i++;
	}
}



===== File: ./src/algo/small_sorts.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   small_sorts.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pedroribeiro <pedroribeiro@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 23:33:38 by procha-r          #+#    #+#             */
/*   Updated: 2025/04/27 20:11:24 by pedroribeir      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "sorting.h"
#include "operations.h"

int	find_position(t_stack *a, int val)
{
	t_node	*current;
	int		pos;

	pos = 0;
	current = a->top;
	while (current)
	{
		if (current->value == val)
			return (pos);
		current = current->next;
		pos++;
	}
	return (-1);
}

void	sort_three(t_stack *a)
{
	int	first;
	int	second;
	int	third;

	first = a->top->value;
	second = a->top->next->value;
	third = a->top->next->next->value;
	if (first < second && second < third)
		return ;
	if (first < third && third < second)
	{
		sa(a);
		ra(a);
	}
	else if (second < first && first < third)
		sa(a);
	else if (third < first && first < second)
		rra(a);
	else if (second < third && third < first)
		ra(a);
	else if (third < second && second < first)
	{
		sa(a);
		rra(a);
	}
}

void	sort_five(t_stack *a, t_stack *b)
{
	int	min;
	int	pos;

	while (a->size > 3)
	{
		min = find_min(a);
		pos = find_position(a, min);
		if (pos <= a->size / 2)
		{
			while (a->top->value != min)
				ra(a);
		}
		else
		{
			while (a->top->value != min)
				rra(a);
		}
		pb(a, b);
	}
	sort_three(a);
	while (!is_empty(b))
		pa(a, b);
}



===== File: ./src/algo/medium_sorts.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   medium_sorts.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pedroribeiro <pedroribeiro@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 23:55:52 by procha-r          #+#    #+#             */
/*   Updated: 2025/04/27 16:48:30 by pedroribeir      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "sorting.h"
#include "operations.h"

int	*extract_values(t_stack *a, int chunk, int chunk_size, int *count)
{
	int		*values;
	int		i;
	t_node	*current;

	values = malloc(sizeof(int) * chunk_size);
	if (!values)
		return (NULL);
	current = a->top;
	i = 0;
	while (current != NULL && i < chunk_size)
	{
		if (current->value >= chunk * chunk_size
			&& current->value < (chunk + 1) * chunk_size)
		{
			values[i] = current->value;
			i++;
		}
		current = current->next;
	}
	*count = i;
	return (values);
}

int	find_median(t_stack *a, int chunk, int chunk_size)
{
	int		*values;
	int		count;
	int		median;

	values = extract_values(a, chunk, chunk_size, &count);
	if (!values || count == 0)
	{
		free(values);
		return (0);
	}
	quick_sort(values, 0, count - 1);
	median = values[count / 2];
	free(values);
	return (median);
}

void	push_chunk_to_b(t_stack *a, t_stack *b, int chunk, int chunk_size)
{
	int	median;

	median = find_median(a, chunk, chunk_size);
	while (stack_contains_chunk(a, chunk, chunk_size))
	{
		if (a->top->value <= median)
			pb(a, b);
		else
			ra(a);
	}
}

void	move_back_to_a(t_stack *a, t_stack *b)
{
	while (!is_empty(b))
	{
		if (b->top->value == find_max(b))
			pa(a, b);
		else
			rb(b);
	}
}

void	sort_medium(t_stack *a, t_stack *b)
{
	int	chunk_size;
	int	total_chunks;
	int	current_chunk;

	if (a == NULL || b == NULL || a->size <= 5)
		return ;
	chunk_size = a->size / 5;
	if (a->size % chunk_size == 0)
		total_chunks = 5;
	else
		total_chunks = 6;
	current_chunk = 0;
	while (current_chunk < total_chunks)
	{
		push_chunk_to_b(a, b, current_chunk, chunk_size);
		current_chunk++;
	}
	move_back_to_a(a, b);
}



===== File: ./src/utils/sorting_helpers_2.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sorting_helpers_2.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pedroribeiro <pedroribeiro@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/27 16:49:49 by pedroribeir       #+#    #+#             */
/*   Updated: 2025/04/27 16:50:48 by pedroribeir      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	stack_contains_chunk(t_stack *a, int chunk, int chunk_size)
{
	t_node	*current;
	int		start;
	int		end;

	if (!a || is_empty(a))
		return (0);
	start = chunk * chunk_size;
	end = (chunk + 1) * chunk_size;
	current = a->top;
	while (current)
	{
		if (current->value >= start && current->value < end)
			return (1);
		current = current->next;
	}
	return (0);
}



===== File: ./src/utils/is_sorted.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   is_sorted.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pedroribeiro <pedroribeiro@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/27 20:36:10 by pedroribeir       #+#    #+#             */
/*   Updated: 2025/04/27 20:36:24 by pedroribeir      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	is_sorted(t_stack *stack)
{
	t_node	*current;

	if (!stack || !stack->top)
		return (1);
	current = stack->top;
	while (current && current->next)
	{
		if (current->value > current->next->value)
			return (0);
		current = current->next;
	}
	return (1);
}



===== File: ./src/utils/assign_index.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   assign_index.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/27 21:38:06 by pedroribeir       #+#    #+#             */
/*   Updated: 2025/05/01 20:03:34 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"
#include <stdlib.h>

static int	compare_ints(const void *a, const void *b)
{
	return (*(int *)a - *(int *)b);
}

void	assign_index(t_stack *stack)
{
	int		*values;
	t_node	*current;
	int		i, j;

	if (!stack || stack->size == 0)
		return ;

	// 1️⃣ Allocate and copy values
	values = malloc(sizeof(int) * stack->size);
	if (!values)
		handle_exit(stack, NULL);
	current = stack->top;
	i = 0;
	while (current)
	{
		values[i++] = current->value;
		current = current->next;
	}

	// 2️⃣ Sort values
	qsort(values, stack->size, sizeof(int), compare_ints);

	// 3️⃣ Assign index to each node based on sorted array
	current = stack->top;
	while (current)
	{
		j = 0;
		while (j < stack->size)
		{
			if (current->value == values[j])
			{
				current->index = j;
				break ;
			}
			j++;
		}
		current = current->next;
	}

	free(values);
}



===== File: ./src/utils/error_handling.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error_handling.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/31 08:03:34 by procha-r          #+#    #+#             */
/*   Updated: 2025/01/31 08:11:44 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	print_error(void)
{
	write(2, "Error\n", 6);
}

void	handle_exit(t_stack *a, t_stack *b)
{
	if (a)
		free_stack(a);
	if (b)
		free_stack(b);
	exit(EXIT_FAILURE);
}



===== File: ./src/utils/parsing_helpers.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_helpers.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pedroribeiro <pedroribeiro@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/27 20:03:08 by pedroribeir       #+#    #+#             */
/*   Updated: 2025/04/27 20:16:26 by pedroribeir      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

static int	handle_sign(const char *str, int *i)
{
	int	sign;

	sign = 1;
	if (str[*i] == '-' || str[*i] == '+')
	{
		if (str[*i] == '-')
			sign = -1;
		(*i)++;
	}
	return (sign);
}

int	safe_atoi(const char *str, int *out)
{
	long	result;
	int		sign;
	int		i;

	if (!str || !out)
		return (0);
	result = 0;
	i = 0;
	sign = handle_sign(str, &i);
	if (str[i] == '\0')
		return (0);
	while (str[i])
	{
		if (str[i] < '0' || str[i] > '9')
			return (0);
		result = result * 10 + (str[i] - '0');
		if ((sign == 1 && result > 2147483647)
			|| (sign == -1 && result > 2147483648))
			return (0);
		i++;
	}
	*out = (int)(result * sign);
	return (1);
}



===== File: ./src/utils/sorting_helpers_4.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sorting_helpers_4.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/28 17:01:41 by procha-r          #+#    #+#             */
/*   Updated: 2025/05/01 19:53:31 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "sorting.h"
#include "operations.h"

void	push_chunk_to_b_big(t_stack *a, t_stack *b, int lo, int hi)
{
	int	pos;

	while (contains_in_chunk(a, lo, hi))
	{
		pos = find_nearest_pos(a, lo, hi);
		rotate_a_to_pos(a, pos);
		pb(a, b);
		if (b->top && b->top->index < (lo + hi) / 2)
			rb(b);
	}
}

void	pull_b_to_a(t_stack *a, t_stack *b)
{
	int	max;

	while (!is_empty(b))
	{
		max = find_max_index(b);
		while (b->top->index != max)
		{
			if (find_max_pos(b) <= b->size / 2)
				rb(b);
			else
				rrb(b);
		}
		pa(a, b);
	}
}



===== File: ./src/utils/ft_split.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pedroribeiro <pedroribeiro@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/11 03:01:04 by pedroribeir       #+#    #+#             */
/*   Updated: 2025/05/02 17:07:53 by pedroribeir      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

static int	count_words(const char *s, char c)
{
	int	count;
	int	in_word;

	count = 0;
	in_word = 0;
	while (*s)
	{
		if (*s != c && in_word == 0)
		{
			in_word = 1;
			count++;
		}
		else if (*s == c)
			in_word = 0;
		s++;
	}
	return (count);
}

static char	*copy_word(const char *s, int len)
{
	char	*word;
	int		i;

	word = (char *)malloc(sizeof(char) * (len + 1));
	if (!word)
		return (NULL);
	i = 0;
	while (i < len)
	{
		word[i] = s[i];
		i++;
	}
	word[i] = '\0';
	return (word);
}

static void	free_words(char **words, int i)
{
	while (i > 0)
	{
		free(words[i - 1]);
		i--;
	}
	free(words);
}

char	**ft_split(char const *s, char c)
{
	char	**words;
	int		i;
	int		len;

	words = (char **)malloc(sizeof(char *) * (count_words(s, c) + 1));
	if (!words || !s)
		return (NULL);
	i = 0;
	while (*s)
	{
		if (*s != c)
		{
			len = 0;
			while (s[len] && s[len] != c)
				len++;
			words[i] = copy_word(s, len);
			if (!words[i++])
				return (free_words(words, i - 1), NULL);
			s += len;
		}
		else
			s++;
	}
	words[i] = NULL;
	return (words);
}



===== File: ./src/utils/debug.c =====



===== File: ./src/utils/ft_free_split.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_free_split.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pedroribeiro <pedroribeiro@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 17:00:43 by pedroribeir       #+#    #+#             */
/*   Updated: 2025/05/02 17:00:58 by pedroribeir      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

void	ft_free_split(char **arr)
{
	int	i;

	if (!arr)
		return ;
	i = 0;
	while (arr[i])
		free(arr[i++]);
	free(arr);
}



===== File: ./src/utils/ops_rotate_helpers.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ops_rotate_helpers.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pedroribeiro <pedroribeiro@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/27 17:16:13 by pedroribeir       #+#    #+#             */
/*   Updated: 2025/04/27 17:17:18 by pedroribeir      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	rotate_stack(t_stack *stack)
{
	t_node	*temp;
	t_node	*last;

	if (!stack || stack->size < 2)
		return ;
	temp = stack->top;
	stack->top = temp->next;
	temp->next = NULL;
	last = stack->top;
	while (last->next)
		last = last->next;
	last->next = temp;
}

void	reverse_rotate_stack(t_stack *stack)
{
	t_node	*prev;
	t_node	*last;

	if (!stack || stack->size < 2)
		return ;
	prev = NULL;
	last = stack->top;
	while (last->next)
	{
		prev = last;
		last = last->next;
	}
	if (prev)
		prev->next = NULL;
	last->next = stack->top;
	stack->top = last;
}



===== File: ./src/utils/sorting_helpers.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sorting_helpers.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 22:43:07 by procha-r          #+#    #+#             */
/*   Updated: 2025/05/01 18:58:14 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "sorting.h"
#include <stdlib.h>

int	partition(int *arr, int low, int high)
{
	int	pivot;
	int	i;
	int	j;
	int	temp;

	pivot = arr[high];
	i = low - 1;
	j = low;
	while (j < high)
	{
		if (arr[j] < pivot)
		{
			i++;
			temp = arr[i];
			arr[i] = arr[j];
			arr[j] = temp;
		}
		j++;
	}
	temp = arr[i + 1];
	arr[i + 1] = arr[high];
	arr[high] = temp;
	return (i + 1);
}

void	quick_sort(int *arr, int low, int high)
{
	int	pivot;

	if (low < high)
	{
		pivot = partition(arr, low, high);
		quick_sort(arr, low, pivot - 1);
		quick_sort(arr, pivot +1, high);
	}
}

int	find_max(t_stack *stack)
{
	t_node	*current;
	int		max;

	if (!stack || !stack->top)
		return (-2147483648);
	current = stack->top;
	max = current->value;
	while (current)
	{
		if (current->value > max)
			max = current->value;
		current = current->next;
	}
	return (max);
}

int	find_min(t_stack *stack)
{
	t_node	*current;
	int		min;

	if (!stack || !stack->top)
		return (2147483647);
	current = stack->top;
	min = current->value;
	current = current->next;
	while (current)
	{
		if (current->value < min)
			min = current->value;
		current = current->next;
	}
	return (min);
}

int	find_second_min(t_stack *stack)
{
	t_node	*current;
	int		min;
	int		second_min;

	if (!stack || !stack->top || !stack->top->next)
		return (2147483647);
	min = find_min(stack);
	second_min = 2147483647;
	current = stack->top;
	while (current)
	{
		if (current->value > min && current->value < second_min)
			second_min = current->value;
		current = current->next;
	}
	if (second_min == 2147483647)
		return (min);
	return (second_min);
}

int	find_max_index(t_stack *stack)
{
	t_node	*current;
	int		max;

	if (!stack || !stack->top)
		return (0);
	current = stack->top;
	max = current->index;
	while (current)
	{
		if (current->index > max)
			max = current->index;
		current = current->next;
	}
	return (max);
}



===== File: ./src/utils/sorting_helpers_3.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sorting_helpers_3.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/28 17:00:53 by procha-r          #+#    #+#             */
/*   Updated: 2025/04/28 17:03:11 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "sorting.h"
#include "operations.h"

int	contains_in_chunk(t_stack *a, int lo, int hi)
{
	t_node	*cur;

	if (!a || is_empty(a))
		return (0);
	cur = a->top;
	while (cur)
	{
		if (cur->index >= lo && cur->index <= hi)
			return (1);
		cur = cur->next;
	}
	return (0);
}

int	find_nearest_pos(t_stack *a, int lo, int hi)
{
	t_node	*cur;
	int		pos;

	cur = a->top;
	pos = 0;
	while (cur)
	{
		if (cur->index >= lo && cur->index <= hi)
			return (pos);
		cur = cur->next;
		pos++;
	}
	return (-1);
}

void	rotate_a_to_pos(t_stack *a, int pos)
{
	int	half;

	if (pos < 0)
		return ;
	half = a->size / 2;
	if (pos <= half)
	{
		while (pos-- > 0)
			ra(a);
	}
	else
	{
		pos = a->size - pos;
		while (pos-- > 0)
			rra(a);
	}
}

int	find_max_pos(t_stack *b)
{
	t_node	*cur;
	int		pos;
	int		max;
	int		max_pos;

	if (!b || is_empty(b))
		return (-1);
	cur = b->top;
	pos = 0;
	max = cur->index;
	max_pos = 0;
	while (cur)
	{
		if (cur->index > max)
		{
			max = cur->index;
			max_pos = pos;
		}
		cur = cur->next;
		pos++;
	}
	return (max_pos);
}

void	rotate_b_to_max(t_stack *b)
{
	int	pos;
	int	half;

	pos = find_max_pos(b);
	if (pos < 0)
		return ;
	half = b->size / 2;
	if (pos <= half)
	{
		while (pos-- > 0)
			rb(b);
	}
	else
	{
		pos = b->size - pos;
		while (pos-- > 0)
			rrb(b);
	}
}



===== File: ./src/utils/ft_count_split.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_count_split.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pedroribeiro <pedroribeiro@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 17:02:07 by pedroribeir       #+#    #+#             */
/*   Updated: 2025/05/02 17:02:08 by pedroribeir      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

int	ft_count_split(char **split)
{
	int i = 0;
	if (!split)
		return (0);
	while (split[i])
		i++;
	return (i);
}



===== File: ./src/operations/ops_reverse_rotate.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ops_reverse_rotate.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pedroribeiro <pedroribeiro@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 23:29:09 by procha-r          #+#    #+#             */
/*   Updated: 2025/04/27 17:22:16 by pedroribeir      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "operations.h"

void	rra(t_stack *a)
{
	reverse_rotate_stack(a);
	write(1, "rra\n", 4);
}

void	rrb(t_stack *b)
{
	reverse_rotate_stack(b);
	write(1, "rrb\n", 4);
}

void	rrr(t_stack *a, t_stack *b)
{
	reverse_rotate_stack(a);
	reverse_rotate_stack(b);
	write(1, "rrr\n", 4);
}



===== File: ./src/operations/ops_rotate.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ops_rotate.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pedroribeiro <pedroribeiro@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 23:16:07 by procha-r          #+#    #+#             */
/*   Updated: 2025/04/27 17:20:43 by pedroribeir      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "operations.h"

void	ra(t_stack *a)
{
	rotate_stack(a);
	write(1, "ra\n", 3);
}

void	rb(t_stack *b)
{
	rotate_stack(b);
	write(1, "rb\n", 3);
}

void	rr(t_stack *a, t_stack *b)
{
	rotate_stack(a);
	rotate_stack(b);
	write(1, "rr\n", 3);
}



===== File: ./src/operations/ops_push.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ops_push.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pedroribeiro <pedroribeiro@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 22:56:28 by procha-r          #+#    #+#             */
/*   Updated: 2025/05/02 17:37:03 by pedroribeir      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "operations.h"

void	pa(t_stack *a, t_stack *b)
{
	t_node	*node;

	node = NULL;
	if (is_empty(b))
		return ;
	node = pop_stack(b);
	push_stack(a, node->value, node->index);
	write(1, "pa\n", 3);
}

void	pb(t_stack *a, t_stack *b)
{
	t_node	*node;

	if (is_empty(a))
		return ;
	node = pop_stack(a);
	push_stack(b, node->value, node->index);
	free(node);
	write(1, "pb\n", 3);
}



===== File: ./src/operations/ops_swap.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ops_swap.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pedroribeiro <pedroribeiro@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 23:11:25 by procha-r          #+#    #+#             */
/*   Updated: 2025/04/27 18:30:11 by pedroribeir      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "operations.h"

static void	silent_swap(t_stack *stack)
{
	int	temp;

	if (is_empty(stack) || stack->size < 2)
		return ;
	temp = stack->top->value;
	stack->top->value = stack->top->next->value;
	stack->top->next->value = temp;
}

void	sa(t_stack *a)
{
	silent_swap(a);
	write(1, "sa\n", 3);
}

void	sb(t_stack *b)
{
	silent_swap(b);
	write(1, "sb\n", 3);
}

void	ss(t_stack *a, t_stack *b)
{
	silent_swap(a);
	silent_swap(b);
	write(1, "ss\n", 3);
}



===== File: ./src/main.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pedroribeiro <pedroribeiro@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/29 21:30:04 by procha-r          #+#    #+#             */
/*   Updated: 2025/05/02 17:24:17 by pedroribeir      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	sort_stack(t_stack *a, t_stack *b)
{
	if (a->size == 2)
	{
		if (a->top->value > a->top->next->value)
			sa(a);
	}
	else if (a->size == 3)
		sort_three(a);
	else if (a->size > 3 && a->size <= 5)
		sort_five(a, b);
	else
		radix_sort(a, b);
}

int	main(int argc, char **argv)
{
	t_stack		a;
	t_stack		b;
	t_input		in;
	int			parse_result;

	if (argc == 1)
		return (0);
	init_stack(&a);
	init_stack(&b);
	in = normalize_argv(argc, argv);
	if (!in.args || in.count == 0)
		handle_exit(&a, &b);
	parse_result = parse_input(in.args, &a, in.count);
	if (parse_result == -1 || check_duplicates(&a))
	{
		print_error();
		if (in.is_split)
			ft_free_split(in.args);
		handle_exit(&a, &b);
	}
	if (is_sorted(&a))
	{
		if (in.is_split)
			ft_free_split(in.args);
		free_stack(&a);
		free_stack(&b);
		return (0);
	}
	assign_index(&a);
	sort_stack(&a, &b);
	if (in.is_split)
		ft_free_split(in.args);
	free_stack(&a);
	free_stack(&b);
	return (0);
}



===== File: ./src/stack/stack_init.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   stack_init.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/29 22:01:18 by procha-r          #+#    #+#             */
/*   Updated: 2025/01/29 22:05:17 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "stacks.h"
#include <stdlib.h>

void	init_stack(t_stack *stack)
{
	if (!stack)
		return ;
	stack->top = NULL;
	stack->size = 0;
}

void	free_stack(t_stack *stack)
{
	t_node	*current;
	t_node	*temp;

	if (!stack)
		return ;
	current = stack->top;
	while (current)
	{
		temp = current;
		current = current->next;
		free(temp);
	}
	stack->top = NULL;
	stack->size = 0;
}



===== File: ./src/stack/stack_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   stack_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: procha-r <procha-r@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/29 22:18:08 by procha-r          #+#    #+#             */
/*   Updated: 2025/01/31 08:09:46 by procha-r         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "stacks.h"

int	stack_size(t_stack *stack)
{
	return (stack->size);
}

int	is_empty(t_stack *stack)
{
	if (!stack)
		return (1);
	return (stack->size == 0);
}

int	peek(t_stack *stack)
{
	if (is_empty(stack))
		return (0);
	return (stack->top->value);
}



===== File: ./src/stack/stack_ops.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   stack_ops.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pedroribeiro <pedroribeiro@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/29 22:22:13 by procha-r          #+#    #+#             */
/*   Updated: 2025/05/02 17:39:05 by pedroribeir      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "stacks.h"
#include <stdlib.h>

void	push_stack(t_stack *stack, int val, int index)
{
	t_node	*new_node;

	if (!stack)
		return ;
	new_node = malloc(sizeof(t_node));
	if (!new_node)
		return ;
	new_node->value = val;
	new_node->index = index;
	new_node->next = stack->top;
	stack->top = new_node;
	stack->size++;
}

t_node	*pop_stack(t_stack *stack)
{
	t_node	*node;

	if (!stack || !stack->top)
		return (NULL);
	node = stack->top;
	stack->top = node->next;
	node->next = NULL;
	stack->size--;
	return (node);
}



